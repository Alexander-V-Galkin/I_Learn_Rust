fn main() {
    // {} замещается аргументом.
    println!("{} days", 31);
    // Позиционные аргументы. Нумерация аргументов начинается с 0.
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");
    // Именованные аргументы. Все аргументы должны использоваться.
    println!(
        "{subject} {verb} {object}",
        object = "ленивю собаку",
        subject = "быстрая рыжая лиса",
        verb = "перепрыгнула"
    );
    // Вывод числа в различных системах счисления.
    println!("Base 10              : {}", 69420);
    println!("Base  2 (binary)     : {:b}", 69420);
    println!("Base  8 (octal)      : {:o}", 69420);
    println!("Base 16 (hexadecimal): {:x}", 69420);
    // Выравнивание вывода по правому, левому краю и по центру. Указание символа-заполнителя.
    println!("{number:>5}", number = 3);
    println!("{number:*<5}", number = 3);
    println!("{number:_^5}", number = 4);
    // Использование именованных аргументов для символов форматирования
    println!("{number:*>width$}", number = 3, width = 5);
    // Соответствие количества позиционных аргументов и количества параметров проверяется.
    println!("My name is {1}, {0} {1}", "James", "Bond");
    // Отключаем вывод предупреждения при компиляции о неиспользуемом коде
    #[allow(dead_code)]
    struct Structure(i32);
    // Распечатать можно только пользовательские типы, которые реализуют fmt::Display
    //println!("Структура {} не может быть распечатана.", Structure(28));
    // Макрос println! может использовать переменные из текущей области видимости
    let number: f64 = 12.07;
    let width: usize = 7;
    println!("{number:>width$}");

    let pi = 3.141592;
    let precis = 3;
    println!("Значение числа Пи приблизительно равно {pi:.3}");
    println!("Значение числа Пи приблизительно равно {pi:.precis$}");
}
